class Solution {
    /**
     * 方法一：使用堆疊（Stack）- 標準解法
     * 利用堆疊後進先出的特性來匹配括號
     */
    public boolean isValid(String s) {
        // 邊界情況：空字串或長度為奇數的字串一定不是有效的括號組合
        if (s == null || s.length() % 2 == 1) {
            return false;
        }
        
        // 建立堆疊來存儲左括號
        Stack<Character> stack = new Stack<>();
        
        // 遍歷字串中的每個字符
        for (char c : s.toCharArray()) {
            // 如果是左括號，推入堆疊
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            }
            // 如果是右括號，檢查是否能與堆疊頂部的左括號匹配
            else if (c == ')' || c == ']' || c == '}') {
                // 如果堆疊為空，說明沒有對應的左括號
                if (stack.isEmpty()) {
                    return false;
                }
                
                // 彈出堆疊頂部的左括號
                char top = stack.pop();
                
                // 檢查括號是否匹配
                if ((c == ')' && top != '(') ||
                    (c == ']' && top != '[') ||
                    (c == '}' && top != '{')) {
                    return false;
                }
            }
        }
        
        // 最後檢查堆疊是否為空，空的話表示所有括號都有匹配
        return stack.isEmpty();
    }
}



/*
解題思路：
1. 遇到左括號就推入堆疊
2. 遇到右括號就檢查能否與堆疊頂部的左括號匹配
3. 如果匹配，彈出堆疊頂部元素；如果不匹配，返回 false
4. 最後檢查堆疊是否為空


核心概念：
- 堆疊的後進先出特性完美匹配括號的嵌套結構
- 左括號入棧，右括號出棧並檢查匹配
- 最終堆疊為空表示所有括號都正確匹配

時間複雜度：O(n) - 需要遍歷整個字串
空間複雜度：O(n) - 最壞情況下堆疊存儲所有字符

邊界情況：
1. 空字串：通常定義為有效
2. 奇數長度字串：一定無效
3. 只有右括號：堆疊為空時無法匹配
4. 只有左括號：最後堆疊不為空

*/