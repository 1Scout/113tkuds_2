class Solution {
    // 主要解法：一次遍歷檢查
    public boolean isValidSudoku(char[][] board) {
        // 使用 HashSet 記錄已經出現的數字
        // 分別記錄每一行、每一列、每一個3x3小方格中出現的數字
        Set<String> seen = new HashSet<>();
        
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                
                // 跳過空格
                if (c != '.') {
                    // 為每個數字創建唯一的識別字串
                    String row = c + " in row " + i;      // 行檢查
                    String col = c + " in col " + j;      // 列檢查
                    String box = c + " in box " + i/3 + "-" + j/3; // 3x3方格檢查
                    
                    // 如果任何一個識別字串已經存在，說明有重複
                    if (!seen.add(row) || !seen.add(col) || !seen.add(box)) {
                        return false;
                    }
                }
            }
        }
        
        return true;
    }
}

/*
題目：有效的數獨

判斷一個 9x9 的數獨是否有效。只需要根據以下規則，驗證已經填入的數字是否有效即可：
1. 數字 1-9 在每一行只能出現一次
2. 數字 1-9 在每一列只能出現一次  
3. 數字 1-9 在每一個 3x3 宮內只能出現一次

注意：
- 空白格用 '.' 表示
- 數獨部分空格內已填入了數字，空白格用'.'表示
- 不需要判斷數獨是否可解，只需驗證已填入的數字是否有效

解法分析：

HashSet 一次遍歷（推薦）
- 時間複雜度：O(1) - 固定為 9x9 的網格
- 空間複雜度：O(1) - 最多存儲 243 個字符串
- 思路：為每個數字創建唯一識別字符串，檢查是否重複

關鍵技巧：
1. 3x3方格索引計算：(i/3) * 3 + j/3
2. 字符轉數字：c - '1' 得到索引 0-8
3. 位運算遮罩：1 << num 創建對應位的遮罩

測試理解：
- board[i][j] = '5' 在位置 (4,6)
- 行索引：4，列索引：6，方格索引：(4/3)*3 + 6/3 = 1*3 + 2 = 5
- 即第4行、第6列、第5個3x3方格都不能再出現'5'
*/