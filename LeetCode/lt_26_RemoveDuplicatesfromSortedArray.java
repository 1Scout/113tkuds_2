class Solution {
    /**
     * 方法一：雙指針法（推薦）
     * 使用快慢指針，慢指針指向不重複元素的位置，快指針用來遍歷陣列
     */
    public int removeDuplicates(int[] nums) {
        // 邊界情況：空陣列
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        // 慢指針，指向下一個不重複元素應該放置的位置
        // 初始化為1，因為第一個元素一定是不重複的
        int slow = 1;
        
        // 快指針從第二個元素開始遍歷
        for (int fast = 1; fast < nums.length; fast++) {
            // 如果快指針指向的元素與前一個元素不同（即發現新的不重複元素）
            if (nums[fast] != nums[fast - 1]) {
                // 將新元素放到慢指針位置
                nums[slow] = nums[fast];
                // 慢指針向前移動
                slow++;
            }
            // 如果快指針指向的元素是重複的，快指針繼續向前，慢指針不動
        }
        
        // 返回不重複元素的個數（慢指針的位置就是長度）
        return slow;
    }
}
/*
解題思路：
1. 使用快慢指針技巧
2. 慢指針指向不重複陣列的末尾位置
3. 快指針遍歷整個陣列，尋找不重複元素
4. 遇到不重複元素時，放到慢指針位置並移動慢指針
核心思想：
1. 由於陣列已經排序，重複元素一定相鄰
2. 只需要與前一個元素比較即可判斷是否重複
3. 使用雙指針在原地修改陣列

時間複雜度：O(n) - 只需要遍歷一次陣列
空間複雜度：O(1) - 只使用常數額外空間

關鍵技巧：
1. 雙指針：快指針探索，慢指針維護結果
2. 原地修改：不使用額外空間
3. 排序特性：重複元素必定相鄰

算法演示：
原陣列：[0,0,1,1,1,2,2,3,3,4]
目標：  [0,1,2,3,4,_,_,_,_,_]

步驟分解（方法一）：
初始：slow=1, fast=1
nums[1]=0, nums[0]=0, 0==0，fast++
nums[2]=1, nums[1]=0, 1!=0，nums[1]=1，slow=2，fast++
nums[3]=1, nums[2]=1, 1==1，fast++
nums[4]=1, nums[3]=1, 1==1，fast++
nums[5]=2, nums[4]=1, 2!=1，nums[2]=2，slow=3，fast++
...以此類推

最終結果：[0,1,2,3,4,_,_,_,_,_]，長度為5

邊界情況：
1. 空陣列：返回0
2. 單元素陣列：返回1
3. 無重複元素：返回原長度
4. 全部重複元素：返回1

測試案例：
輸入：[1,1,2]
輸出：2，陣列變為[1,2,_]

輸入：[0,0,1,1,1,2,2,3,3,4]  
輸出：5，陣列變為[0,1,2,3,4,_,_,_,_,_]

題目要求注意點：
1. 原地修改陣列（O(1)額外空間）
2. 返回新長度
3. 元素的相對順序不能改變
4. 不用擔心新長度後面的元素

雙指針技巧總結：
- 快指針：負責探索新元素
- 慢指針：負責維護結果陣列
- 這種模式在很多陣列去重問題中都適用
*/